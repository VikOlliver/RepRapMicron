#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# png_to_gcode - Convert a PNG image to GCODE dot plot instructions
# Notionally in mm though RepRapMicron runs at 1 mm = 1 micron
#
# Copyright (C) 2025 Vik Olliver <vik@diamondage.co.nz>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import argparse
import sys
from PIL import Image

# === Movement speed configuration ===
FEED_MOVE = 1500    # XY movement speed (CNC units/min)
FEED_Z = 500        # Z-axis movement speed (CNC units/min)

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Convert a PNG image into GCODE dots for plotting or engraving.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument("input", help="Input PNG file (use '-' to read from stdin)")
    parser.add_argument("-o", "--output", help="Output GCODE file (use '-' for stdout)", default="-")
    parser.add_argument("-d", "--distance", help="Distance per pixel in CNC units", type=float, default=10.0)
    parser.add_argument("--safe-z", help="Safe travel height in mm", type=float, default=50.0)
    parser.add_argument("--draw-z", help="Drawing/contact height in mm", type=float, default=0.0)
    parser.add_argument("--light", action="store_true", help="Plot light pixels instead of dark ones")
    parser.add_argument("--threshold", help="Brightness threshold (0–255)", type=int, default=127)
    parser.add_argument("--no-invert-y", action="store_true", help="Don’t flip Y axis (default is flipped for CNC-type layout)")

    return parser.parse_args()

def load_image(path):
    if path == "-":
        img = Image.open(sys.stdin.buffer)
    else:
        img = Image.open(path)
    return img.convert("L")  # Convert to grayscale

def emit_gcode(f, img, config):
    width, height = img.size

    f.write("; GCODE generated by png_to_gcode\n")
    f.write("G21 ; Set units to mm\n")
    f.write("G90 ; Absolute positioning\n")
    f.write(f"G1 Z{config.safe_z:.2f} F{FEED_Z} ; Move to safe Z height\n\n")

    for y in range(height):
        for x in range(width):
            pixel = img.getpixel((x, y))
            condition = pixel > config.threshold if config.light else pixel < config.threshold

            if condition:
                gx = x * config.distance
                gy = (height - 1 - y if not config.no_invert_y else y) * config.distance

                f.write(f"G1 Z{config.safe_z:.2f} F{FEED_Z} ; Safe Z\n")
                f.write(f"G1 X{gx:.2f} Y{gy:.2f} F{FEED_MOVE} ; Move to pixel\n")
                f.write(f"G1 Z{config.draw_z:.2f} F{FEED_Z} ; Pen down\n")
                f.write(f"G1 Z{config.safe_z:.2f} F{FEED_Z} ; Pen up\n\n")

    f.write(f"G1 Z{config.safe_z:.2f} F{FEED_Z} ; Final safe Z\n")
    f.write("; End of GCODE\n")

def main():
    args = parse_arguments()
    img = load_image(args.input)

    if args.output == "-":
        emit_gcode(sys.stdout, img, args)
    else:
        with open(args.output, "w") as f:
            emit_gcode(f, img, args)

if __name__ == "__main__":
    main()
